# 最高連續打卡完整說明

> 📅 **最後更新：** 2026-01-16
> 🎯 **版本：** v2.0 - 從「當前連續」改為「最高連續」

---

## 目錄

1. [核心概念](#核心概念)
2. [計算邏輯](#計算邏輯)
3. [範例說明](#範例說明)
4. [後端實作](#後端實作)
5. [前端更新](#前端更新)
6. [測試驗證](#測試驗證)
7. [常見問題](#常見問題)

---

## 核心概念

### 什麼是「最高連續打卡」？

**定義：** 學員在整個課程期間，曾經達到的**最長連續打卡紀錄**

**與「當前連續」的差異：**

| 項目 | 舊邏輯（當前連續） | 新邏輯（最高連續） |
|-----|-----------------|-----------------|
| 計算方式 | 從最近往回算，遇中斷停止 | 掃描所有歷史，取最長段 |
| 是否需包含今天 | 必須（超過1天歸零） | 不需要 |
| 中斷後的影響 | 連續天數歸零 | 保留最高紀錄 |
| 鼓勵性 | 較低（容易歸零） | 較高（保留成就） |

**優點：**
- ✅ 保留歷史最佳成績
- ✅ 不受今天是否打卡影響
- ✅ 即使中斷，之前的最高紀錄仍保留
- ✅ 更具鼓勵性，減少挫折感

---

## 計算邏輯

### 演算法流程

```
1. 收集所有打卡日期（去除重複）
2. 從舊到新排序
3. 掃描所有連續段
   ├─ 如果相鄰兩天剛好相差 1 天 → 連續
   └─ 如果相差超過 1 天 → 中斷，重新開始計算
4. 記錄最長的連續段
5. 回傳最高紀錄
```

### 核心程式碼（Apps Script）

```javascript
// 計算最高連續打卡天數
let maxConsecutiveDays = 1; // 至少有 1 天
let currentConsecutive = 1;

// 從舊到新掃描所有打卡日期
for (let j = 1; j < sortedDates.length; j++) {
  const currentDate = sortedDates[j];
  const previousDate = sortedDates[j - 1];

  const diff = Math.floor((currentDate - previousDate) / (24 * 60 * 60 * 1000));

  if (diff === 1) {
    // 連續，增加計數
    currentConsecutive++;
    maxConsecutiveDays = Math.max(maxConsecutiveDays, currentConsecutive);
  } else {
    // 中斷，重新開始計算
    currentConsecutive = 1;
  }
}

return maxConsecutiveDays;
```

**時間複雜度：** O(n log n)，其中 n 為打卡天數

---

## 範例說明

### 範例 1：學員001 - 完美連續

**打卡記錄：**
```
01-01, 01-02, 01-03, 01-04, 01-05, 01-06, 01-07, 01-08,
01-09, 01-10, 01-11, 01-12, 01-13, 01-14, 01-15, 01-16
```

**計算過程：**
- 從 01-01 開始掃描
- 每一天都剛好相差 1 天
- 最長連續段 = 16 天

**結果：最高連續打卡 = 16 天** ✅

---

### 範例 2：學員002 - 中間有中斷（重點範例）

**打卡記錄：**
```
第一段：01-01, 01-02, 01-03, 01-04 (4天)
         ❌ 缺 01-05
第二段：01-06, 01-07, 01-08, 01-09, 01-10, 01-11 (6天) ← 最高
         ❌ 缺 01-12, 01-13
第三段：01-14, 01-15, 01-16 (3天)
```

**計算過程：**
```
掃描第一段：01-01 → 01-04 = 4天連續
記錄最高：4天

遇到中斷（缺01-05）

掃描第二段：01-06 → 01-11 = 6天連續
記錄最高：max(4, 6) = 6天

遇到中斷（缺01-12, 01-13）

掃描第三段：01-14 → 01-16 = 3天連續
記錄最高：max(6, 3) = 6天

最終結果：最高連續打卡 = 6天
```

**打卡時間軸視覺化：**
```
01-01 ✅ ┐
01-02 ✅ │ 第一段：4天連續
01-03 ✅ │
01-04 ✅ ┘
01-05 ❌ ← 中斷

01-06 ✅ ┐
01-07 ✅ │
01-08 ✅ │ 第二段：6天連續 ⭐ 最高紀錄
01-09 ✅ │
01-10 ✅ │
01-11 ✅ ┘
01-12 ❌ ← 中斷
01-13 ❌ ← 中斷

01-14 ✅ ┐
01-15 ✅ │ 第三段：3天連續
01-16 ✅ ┘
```

**結果：最高連續打卡 = 6 天** ✅

**說明：**
- 雖然最近只連續 3 天（01-14~16）
- 但之前曾達到 6 天連續（01-06~11）
- 系統保留最高紀錄 = 6 天

---

### 範例 3：學員003 - 晚加入但完美

**打卡記錄：**
```
❌ 01-01 到 01-09 未加入課程
01-10, 01-11, 01-12, 01-13, 01-14, 01-15, 01-16
```

**計算過程：**
- 從 01-10 開始，連續到 01-16
- 沒有中斷

**結果：最高連續打卡 = 7 天** ✅

---

### 範例 4：學員004 - 早期中斷

**打卡記錄：**
```
第一段：01-01, 01-02, 01-03 (3天)
         ❌ 缺 01-04 到 01-13（中斷 11 天）
第二段：01-14, 01-15, 01-16 (3天)
```

**計算過程：**
- 第一段連續：3 天
- 遇到長時間中斷
- 第二段連續：3 天
- 兩段都是 3 天，最高 = 3 天

**結果：最高連續打卡 = 3 天** ✅

**為什麼不是 6 天？**
- 雖然總共打卡 6 天
- 但中間有 11 天的中斷
- 連續打卡只算「不間斷」的天數
- 兩段都只有 3 天連續

---

### 範例 5：學員005 - 稀疏打卡

**打卡記錄：**
```
第一段：01-01, 01-02 (2天)
         ❌ 缺 01-03, 01-04
第二段：01-05 (1天)
         ❌ 01-06 之後都沒打卡
```

**計算過程：**
- 第一段連續：2 天 ← **最高紀錄**
- 遇到中斷
- 第二段：只有 1 天
- 最高 = max(2, 1) = 2 天

**結果：最高連續打卡 = 2 天** ✅

---

## 後端實作

### Google Apps Script - Code_CLEAN.js

**檔案位置：** `scripts/Code_CLEAN.js`

**修改內容（第 269-385 行）：**

1. **改為從舊到新排序**
```javascript
// 從舊到新排序（重要！）
const sortedDates = Array.from(dateSet)
  .map(function(dateStr) {
    const parts = dateStr.split('-');
    return new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
  })
  .sort(function(a, b) { return a - b; }); // 從舊到新
```

2. **計算最高連續段**
```javascript
let maxConsecutiveDays = 1; // 至少有 1 天
let currentConsecutive = 1;

for (let j = 1; j < sortedDates.length; j++) {
  const diff = Math.floor((currentDate - previousDate) / (1000 * 60 * 60 * 24));

  if (diff === 1) {
    // 連續，增加當前連續計數
    currentConsecutive++;
    maxConsecutiveDays = Math.max(maxConsecutiveDays, currentConsecutive);
  } else {
    // 中斷，重新開始計算
    currentConsecutive = 1;
  }
}
```

3. **不再檢查「今天或昨天」**
   - 舊邏輯需要檢查 `daysDiff <= 1`
   - 新邏輯不需要，掃描所有歷史即可

**週報腳本（WeeklyReport.js）：**
- 無需修改，直接從統計表讀取 C 欄數值

---

## 前端更新

### UI 文字更新

**修改的檔案：**

1. **dashboard-wired.html**
   - 我的進度快覽：`🔥 連續打卡` → `🏆 最高連續`
   - 排行榜標題：`🏅 連續打卡王` → `🏅 最高連續打卡王`

2. **js/dashboard.js**
   - 註釋：`渲染連續打卡王排行榜` → `渲染最高連續打卡王排行榜`
   - 個人查詢：`🔥 連續打卡` → `🏆 最高連續`

3. **scripts/WeeklyReport.js**
   - 郵件內容：`🔥 連續打卡` → `🏆 最高連續`

### Emoji 變更

- `🔥`（火焰，代表「當前連續」）→ `🏆`（獎盃，代表「最高紀錄」）

**視覺對照：**

```
舊版：
📅 累計打卡    🔥 連續打卡    🏆 里程碑徽章
   16 天          16 天           🏆🏆

新版：
📅 累計打卡    🏆 最高連續    🏆 里程碑徽章
   16 天          16 天           🏆🏆
```

---

## 測試驗證

### 測試資料（test-data-2026.csv）

**課程設定：**
- 開始日期：2026-01-01
- 今天日期：2026-01-16

**預期結果：**

| 學員 | 打卡模式 | 累計 | 最高連續 |
|------|---------|------|---------|
| 學員001 | 完美連續 16 天 | 16 | **16** ✅ |
| 學員002 | 4天 + (缺) + 6天 + (缺) + 3天 | 13 | **6** ✅ |
| 學員003 | 晚加入，連續 7 天 | 7 | **7** ✅ |
| 學員004 | 3天 + (長期缺) + 3天 | 6 | **3** ✅ |
| 學員005 | 2天 + (缺) + 1天 + (缺) | 3 | **2** ✅ |

### 驗證步驟

1. **匯入測試資料**
   - 將 test-data-2026.csv 內容複製到 Google Sheets「表單回應」

2. **執行計算**
   - Google Apps Script：執行「打卡系統」→「🔄 更新連續天數」

3. **檢查結果**
   - 查看「打卡統計」工作表 C 欄
   - 確認數值符合上表

4. **前端驗證**
   - 清除瀏覽器快取：`localStorage.clear(); location.reload(true);`
   - 檢查儀表板顯示

5. **查看 Log**
   - Apps Script 執行記錄
   - 前 3 位學員會顯示詳細計算過程

---

## 常見問題

### Q1: 為什麼要改成最高連續？

**A:** 更符合鼓勵學員的目標：
- 展現學員的潛力和努力
- 避免因一次失誤而歸零的挫折感
- 保留最佳成績，更有成就感
- 學員可以挑戰「打破自己的紀錄」

---

### Q2: 今天沒打卡會歸零嗎？

**A:** 不會！最高連續是歷史紀錄，不受今天影響。

**範例：**
- 學員曾經連續 10 天（01-01 ~ 01-10）
- 之後中斷了（01-11 沒打卡）
- 最高連續仍然是 **10 天**（保留紀錄）
- 即使後來只打卡 2 天，最高連續依然是 10 天

---

### Q3: 如果後來打出更長的連續會更新嗎？

**A:** 會！系統會持續追蹤並更新最高紀錄。

**範例：**
- 之前最高連續：10 天
- 後來又連續打卡 15 天
- 最高連續更新為：**15 天**

---

### Q4: 前後端的日期設定一定要一致嗎？

**A:** 是的！前後端必須使用相同的日期設定。

**需要同步的地方：**
1. 前端 `js/config.js`
2. 後端 `scripts/Code_CLEAN.js`
3. 後端 `scripts/WeeklyReport.js`

**建議設定：**
```javascript
// 測試模式
const TEST_TODAY_DATE = new Date('2026-01-16');
const COURSE_START_DATE = new Date('2026-01-01');

// 正式模式
const TEST_TODAY_DATE = null;
const COURSE_START_DATE = new Date('2026-01-13'); // 實際開始日期
```

---

### Q5: 排行榜會變成「歷史排名」嗎？

**A:** 是的！排行榜現在展示的是「誰曾經達到最長的連續打卡」。

這更公平，因為：
- 不會因為一次失誤就掉出榜外
- 展現學員的最佳表現
- 更有激勵作用

---

### Q6: 會影響現有資料嗎？

**A:** 會！執行 `updateAllConsecutiveDays` 後，所有學員的連續天數都會重新計算。

**影響：**
- 完美連續的學員：數值不變（仍然是完美）
- 有中斷的學員：可能會**增加**（因為保留最高紀錄）

**範例：**
- 舊邏輯：學員中斷後顯示 3 天（當前連續）
- 新邏輯：學員顯示 10 天（之前曾達到的最高）

---

### Q7: 如果想看「當前連續」怎麼辦？

**A:** 目前系統只記錄「最高連續」。如果需要，可以額外增加一個欄位來追蹤「當前連續」。

**建議：**
- 如果大部分學員都想知道「當前連續」，可以在 D 欄新增
- 兩個指標並存：C 欄最高連續，D 欄當前連續

---

## 部署檢查清單

上線前最後確認：

### 後端（Google Apps Script）

- [ ] Code_CLEAN.js 已更新為最高連續邏輯
- [ ] TEST_TODAY_DATE 已設定正確（測試用特定日期 or null）
- [ ] COURSE_START_DATE 已設定為實際開始日期
- [ ] 已執行「🔄 更新連續天數」
- [ ] 「打卡統計」工作表 C 欄有數值
- [ ] 查看執行記錄確認計算正確

### 前端

- [ ] config.js 的 TEST_TODAY_DATE 與後端一致
- [ ] config.js 的 COURSE_START_DATE 與後端一致
- [ ] UI 顯示「最高連續打卡王」
- [ ] 個人統計顯示「最高連續」
- [ ] 瀏覽器快取已清除

### 測試

- [ ] 使用 test-data-2026.csv 驗證計算正確
- [ ] 前端顯示數值正確
- [ ] 週報郵件顯示「最高連續」

---

## 相關檔案

### 後端程式碼
- `scripts/Code_CLEAN.js` - 主要計算邏輯（第 269-385 行）
- `scripts/WeeklyReport.js` - 週報生成（讀取統計表）

### 前端程式碼
- `dashboard-wired.html` - 主要儀表板
- `js/dashboard.js` - 儀表板邏輯
- `js/config.js` - 配置檔案

### 測試資料
- `test-data-2026.csv` - 完整測試場景

---

## 更新歷史

### v2.0 (2026-01-16)
- 從「當前連續」改為「最高連續」
- 更新所有 UI 顯示文字
- 新增詳細範例說明
- 建立完整測試資料

### v1.0 (2025-12-21)
- 初始版本：當前連續打卡邏輯

---

**如有問題或需要協助，請參閱：**
- 部署指南：[正式上線準備指南](../部署與維護/正式上線準備指南.md)
- 問題診斷：[問題診斷步驟](../部署與維護/問題診斷步驟.md)
